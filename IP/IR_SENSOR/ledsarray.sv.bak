module ledsarray( inout tri [7:0] GPIO_1, // reflectance sensor inout
	output logic [7:0] LED, // reflectance sensor binary signal
	input logic KEY[0], CLOCK_50
	); // reset and clock

	enum logic [2:0] { // enumeration for the states 
		ledsout, // set pins as output
		ledsin, // set pins as input
		wait1, // wait 10 us for sensors to charge
		wait2, // wait x amount before reading sensors
		test,
		count, // count number of zeros,
		count_complete // read sensors
	} state, state_next;
	enum logic [1:0] {
		infinite,
		in,
		out
	} direction; // enum for pin direction, and loop the program forever

	logic signed [31:0] count1, count2; // count register

	parameter tenu = 500; // 10us dealy for sensors to chrage up. (500 clk cycles)
	parameter hunu = 20000; // 100us dealy before checking sensors. (5000 clk cycles)

	reg [8:0] err, err_1, err_2, current;
	reg [4:0] counter = 0;
	reg ready_flag = 1'b0;

	// Register
	initial begin
		err_1 = 8'd0;
		err_2 = 'd0;
	end
	
	reg slow_clock = 1'b1;
	reg [32:0] clock_count = 32'd0;
	
	always_ff @(posedge CLOCK_50) begin
		clock_count <= clock_count + 1;
		if(clock_count >= 32'd125000) begin
			slow_clock <= ~slow_clock;
			clock_count <= 32'd0;
		end
	end
	
	always_ff@(posedge CLOCK_50) begin
		if (state == ledsout)begin
			GPIO_1 <= '1; // set pins high
			direction = out;
			LED[3:0] <= 4'd1;
		end else if (state == ledsin)begin
			GPIO_1 <= 'z; // read from pins
			direction = in;
			LED[3:0] <= 4'd2;
		end

		if (state == wait1) begin // 10us counter
			count1 <= count1 + 1'b1;
			LED[3:0] <= 4'd3;
		end else
			count1 <= 0; // if not counting counter should remain at zero

		if (state == wait2) begin// 100us counter
			count2 <= count2 + 1'b1;
			LED[3:0] <= 4'd4;
		end else
			count2 <= 0; // if not counting counter should remain at zero

		if (state == test) begin
			current <= GPIO_1;
			counter <= 4'd8;
			LED[3:0] <= 4'd5; 
		end
		if (state == count) begin
			current <= {1'b1, current[6:0]};
			counter <= counter - 4'd1;
			LED[3:0] <= 4'd6;
		end
		if(state == count_complete) begin
			err_2 = err_1;
			err_1 = err;
			err = counter - 4'd4;
			counter <= 4'd8;
			LED[3:0] <= 4'd7;
		end
	end

	 
	// Controller register

	always_ff@(posedge CLOCK_50) begin
//		state <= state_next;
	end

	always_comb begin
		state_next = state;

		if ((KEY[0] == 0))
			state_next = ledsout;
		else if (direction == out)
			state_next = wait1;
		else if (count1 >= tenu)
			state_next = ledsin;
		else if (direction == in)
			state_next = wait2;
		else if (count2 >= hunu)
			state_next = test;
		else if(current[0] == 1'b1 || counter > 0)
			state_next = count;
		else if(current[0] == 1'b0)
			state_next = count_complete;
		else
			state_next = test;
	end
endmodule
